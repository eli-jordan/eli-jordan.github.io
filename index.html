<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    <meta property="og:image" content="https://eli-jordan.github.io/css/images/me.jpeg" />
    <meta name="google-site-verification" content="HMdPU_Gv5ZIGS3ijDlOPClxKoBy_H-aRhjHxMKFTlI8" />
    
    <title>Duality</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="Duality">
<meta property="og:url" content="https://eli-jordan.github.io/index.html">
<meta property="og:site_name" content="Duality">
<meta property="og:locale" content="en_GB">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Duality">
<meta property="fb:admins" content="elijordan">
<meta property="fb:app_id" content="166618053965795">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Duality</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/me.jpeg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/me.jpeg" />
            <h2 id="name">Eli Jordan</h2>
            <h3 id="title">Software Engineer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Sydney, Australia</span>
            <a id="follow" target="_blank" href="http://github.com/eli-jordan">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                1
                <span>post</span>
            </div>
            <div class="article-info-block">
                3
                <span>tags</span>
            </div>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-life-is-a-comonad" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/02/16/life-is-a-comonad/">Life Is A Comonad</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/02/16/life-is-a-comonad/">
            <time datetime="2018-02-16T04:30:28.000Z" itemprop="datePublished">2018-02-16</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/comonad/">comonad</a>, <a class="tag-link" href="/tags/functional-programming/">functional-programming</a>, <a class="tag-link" href="/tags/scala/">scala</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>I have recently been grappling with the concept of a <code>Comonad</code>, and found that there are quite a few articles that explain their theoretical footing, but not many that convey an intuitive understanding of Comonads using practical examples. Additionally, the practical examples I did find are all in Haskell, which I am not fluent in.</p>
<p>In this post I aim to convey an intuitive understanding of the structure of a <code>Comonad</code>, and how you can use comonads in real(ish) programs. </p>
<h2 id="What-Is-A-Comonad"><a href="#What-Is-A-Comonad" class="headerlink" title="What Is A Comonad?"></a>What Is A Comonad?</h2><p>A <code>Comonad</code> is the <a href="https://en.wikipedia.org/wiki/Dual_%28category_theory%29" target="_blank" rel="noopener">categorical dual</a> of a <code>Monad</code>. This simply means that we “reverse the arrows” in the definition of a <code>Monad</code></p>
<figure class="highlight scala"><figcaption><span>Monad / Comonad Duality</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](ffa: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Comonad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">A</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we rewrite the types of these functions slightly differently, the reversal of the arrows becomes more obvious.</p>
<figure class="highlight scala"><figcaption><span>Reversing The Arrows</span></figcaption><table><tr><td class="code"><pre><span class="line">unit: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">counit: <span class="type">F</span>[<span class="type">A</span>] =&gt; <span class="type">A</span></span><br><span class="line"></span><br><span class="line">join: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]] =&gt; <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">cojoin: <span class="type">F</span>[<span class="type">A</span>] =&gt; <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="unit-counit"><a href="#unit-counit" class="headerlink" title="unit / counit"></a><code>unit</code> / <code>counit</code></h3><ul>
<li>In a <code>Monad</code> the <code>unit</code> function takes a pure value, and wraps it in an <code>F</code> structure <code>F[A]</code></li>
<li>In a <code>Comonad</code> the <code>counit</code> function takes an <code>F</code> structure and <strong>extracts</strong> a pure value <code>A</code></li>
</ul>
<h3 id="join-cojoin"><a href="#join-cojoin" class="headerlink" title="join / cojoin"></a><code>join</code> / <code>cojoin</code></h3><ul>
<li>In a <code>Monad</code> the <code>join</code> function takes two layers of <code>F</code> structure <code>F[F[A]]</code> and <strong>collapses</strong> it into one layer <code>F[A]</code></li>
<li>In a <code>Comonad</code> the <code>cojoin</code> function takes one layer of <code>F</code> structure <code>F[A]</code> and <strong>duplicates</strong> it <code>F[F[A]]</code></li>
</ul>
<p>Ok, so now we can see that a <code>Comonad</code> is defined by reversing the arrows in the definition of a <code>Monad</code>, but this doesn’t provide an intuitive understanding of how a <code>Comonad</code> behaves.</p>
<h2 id="The-Intuition"><a href="#The-Intuition" class="headerlink" title="The Intuition"></a>The Intuition</h2><p>The <code>Zipper</code> data structure is a good analogy of the behaviour of a <code>Comonad</code>. A <code>Zipper</code> is a sequence of elements, that encodes the idea of a “current” or “focus” element, allowing the focus to be moved left and right efficiently.</p>
<figure class="highlight scala"><figcaption><span>Zipper</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamZipper</span>[<span class="type">A</span>](<span class="params">left: <span class="type">Stream</span>[<span class="type">A</span>], focus: <span class="type">A</span>, right: <span class="type">Stream</span>[<span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">moveLeft</span></span>: <span class="type">StreamZipper</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StreamZipper</span>[<span class="type">A</span>](left.tail, left.head, focus #:: right)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">moveRight</span></span>: <span class="type">StreamZipper</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StreamZipper</span>[<span class="type">A</span>](focus #:: left, right.head, right.tail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>left</code> member contains all elements that precede the focus element, in reverse order. The elements are reversed, so that moving left is just a prepend operation. The <code>right</code> member contains all elements that follow the focus element.</p>
<p>What does this have to do with <code>Comonads</code>? Well, since we have a focus element, we have a way to <strong>extract</strong> an <code>A</code> element from an <code>F[A]</code>, by simply accessing the focus element. This is exactly what we need to implement <code>counit</code></p>
<figure class="highlight scala"><figcaption><span>Counit</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">ZipperComonad</span>[<span class="type">StreamZipper</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">    fa.focus</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But, we still don’t have an implementation for <code>cojoin</code>. What does it mean to create a <code>StreamZipper[StreamZipper[A]]</code>? </p>
<p>They key insight here, is that we want to generate a <code>StreamZipper</code> where each element has the same elements as the initial <code>StreamZipper</code> but with the focus shifted.</p>
<p>For example, denoting the focus element using <code>&gt;x&lt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cojoin([1, &gt;2&lt;, 3]) = [</span><br><span class="line">   [&gt;1&lt;,  2 ,  3 ], </span><br><span class="line">   [ 1 , &gt;2&lt;,  3 ], </span><br><span class="line">   [ 1 ,  2 , &gt;3&lt;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>So, <code>cojoin</code> <strong>duplicates</strong> our structure, but with the focus in each duplicate shifted to one of the other elements. In the <code>StreamZipper</code> example this means that for each element we create a duplicate of the entire <code>StreamZipper</code> and set the focus on that element.</p>
<p>So lets implement this for <code>StreamZipper</code></p>
<figure class="highlight scala"><figcaption><span>StreamZipper cojoin</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamZipper</span>[<span class="type">A</span>](<span class="params">left: <span class="type">Stream</span>[<span class="type">A</span>], focus: <span class="type">A</span>, right: <span class="type">Stream</span>[<span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// A stream of zippers, with the focus set to each element on the left</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> lefts: <span class="type">Stream</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] =</span><br><span class="line">    <span class="type">Stream</span>.iterate(moveLeft)(_.moveLeft).zip(left.tail).map(_._1)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A stream of zippers, with the focus set to each element on the right</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> rights: <span class="type">Stream</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] =</span><br><span class="line">    <span class="type">Stream</span>.iterate(moveRight)(_.moveRight).zip(right.tail).map(_._1)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cojoin: <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]](lefts, <span class="keyword">this</span>, rights)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now defining the <code>Comonad</code> instance is trivial</p>
<figure class="highlight scala"><figcaption><span>Comonad instance</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">ZipperComonad</span>[<span class="type">StreamZipper</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">    fa.focus</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] = </span><br><span class="line">    fa.cojoin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Summarising, a <code>Comonad</code> has two operations</p>
<ul>
<li><code>counit</code> extracts a focus element from a structure</li>
<li><code>cojoin</code> extends the structure, so that for every element in the original structure, there is a copy of the structure with the focus on the corresponding element.</li>
</ul>
<h2 id="Comonad-coflatMap"><a href="#Comonad-coflatMap" class="headerlink" title="Comonad coflatMap"></a>Comonad coflatMap</h2><p>You may have noticed that the definition of <code>Monad</code> that I used is a bit different than how it is normally expressed in scala. In particular, I used <code>unit</code> and <code>join</code> rather than <code>unit</code> and <code>flatMap</code>. However, these definitions are equivalent. Taking our definition of monad, we can define <code>flatMap</code> in terms of <code>map</code> and <code>join</code></p>
<figure class="highlight scala"><figcaption><span>Deriving flatMap</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](ffa: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> <span class="type">F</span>: <span class="type">Functor</span>[<span class="type">F</span>]): <span class="type">F</span>[<span class="type">B</span>] =</span><br><span class="line">     join(<span class="type">F</span>.map(fa)(f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Similarly, for comonad, we can express <code>coflatMap</code> in terms of <code>map</code> and <code>cojoin</code></p>
<figure class="highlight scala"><figcaption><span>Deriving coflatMap</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Comonad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">coflatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">F</span>[<span class="type">A</span>] =&gt; <span class="type">B</span>)(<span class="keyword">implicit</span> <span class="type">F</span>: <span class="type">Functor</span>[<span class="type">F</span>]): <span class="type">F</span>[<span class="type">B</span>] =</span><br><span class="line">    <span class="type">F</span>.map(cojoin(fa))(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I used this definition, since the intuition for <code>cojoin</code> is easier to understand and describe using the <code>StreamZipper</code>. However, the comonad equivalent of <code>flatMap</code>, called <code>coflatMap</code> is a useful function, and we will need to use it later when implementing the Game Of Life.</p>
<p>This function “extends” a local computation into the global context the comonad holds. If you recall, <code>cojoin</code> generates all possible focus points in the comonad structure. In the <code>StreamZipper</code> example, this was a zipper of zippers, where each focused on a different element.</p>
<p>If we inspect the derivation of <code>coflatMap</code>, we are </p>
<ul>
<li>First using <code>cojoin</code> to get a view on all focal points, then</li>
<li>Using the <code>Functor</code> instance to apply a function that performs a “local” computation at all focal points. </li>
</ul>
<p>So, <code>coflatMap</code> allows us to <strong>extend</strong> a local computation to apply in a global context.</p>
<p>A simple example of this, using the <code>StreamZipper</code> is a sliding average. Say we want to take the average of all possible 3 element sub sections of a <code>StreamZipper[Int]</code>. We can define a function that calculates the average, using local information only, by calculating the average of the current focus, the focus one move left and one move right.</p>
<figure class="highlight scala"><figcaption><span>Local Average</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg</span></span>(a: <span class="type">StreamZipper</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> left = a.moveLeft.focus</span><br><span class="line">   <span class="keyword">val</span> current = a.focus</span><br><span class="line">   <span class="keyword">val</span> right = a.moveRight.focus</span><br><span class="line">   (left + current + right) / <span class="number">3</span>d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can then “extend” this local computation, using <code>coflatMap</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">StreamZipper</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>, <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)).coflatMap(avg).toList</span><br><span class="line"><span class="comment">// List(2.0, 3.0, 4.0, 5.0, 6.0)</span></span><br></pre></td></tr></table></figure>
<h2 id="Store-Comonad"><a href="#Store-Comonad" class="headerlink" title="Store Comonad"></a>Store Comonad</h2><p>Now that you have a basic understanding of how comonads behave, our next goal is to actually use one to implement a non-trivial program. In this case, since the comonad structure is well suited to cellular automaton, we will implement <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">Conway’s Game Of Life</a> using the <code>Store</code> comonad.</p>
<p>So, lets first introduce the Store data type. <code>Store</code> is the comonadic dual of the <code>State</code> monad, and takes the following form.</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>You can think of <code>S</code> being an abstract index into the store.</li>
<li>The <code>index</code> field then defines the “focus” element, by defining the index</li>
<li>The <code>lookup</code> function is the “accessor” for a value of type <code>A</code> using an index of type <code>S</code></li>
</ul>
<p>Lets define the comonad operations on the this data type.</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> counit: <span class="type">A</span> = </span><br><span class="line">    lookup(index)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cojoin: <span class="type">Store</span>[<span class="type">S</span>, <span class="type">Store</span>[<span class="type">S</span>, <span class="type">A</span>]] =</span><br><span class="line">    <span class="type">Store</span>(<span class="type">Store</span>(lookup))(index)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Store</span>[<span class="type">S</span>, <span class="type">B</span>] =</span><br><span class="line">    <span class="type">Store</span>(lookup.andThen(f))(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One thing to notice is that <code>Store</code> take two type parameters, so to define a <code>Comonad</code> instance we need to fix one of them. In this case we fix <code>S</code>. </p>
<p><code>counit</code> is trivial, we simply apply the <code>lookup</code> function to the current index.</p>
<p><code>cojoin</code> is more interesting. </p>
<ul>
<li>Since we are fixing <code>S</code> we want to generate <code>Store[A, Store[S, A]]</code>. </li>
<li>Since we are replacing <code>A</code> with <code>Store[S, A]</code>, and <code>A</code> is only used in the return type of <code>lookup</code>, we need to define a new <code>lookup</code> function of type <code>S =&gt; Store[S, A]</code>. </li>
<li>We do this by partially applying the store constructor <code>Store(lookup)</code> since this has exactly the type we need. </li>
<li>We then copy the current store, replacing the <code>lookup</code> function with a partially applied constructor and we’re done.</li>
</ul>
<p>The intuition that <code>cojoin</code> duplicates the structure, with the focus shifted, is a little harder to see in <code>Store</code>, but it is still there.</p>
<ul>
<li>We can think of <code>S =&gt; A</code> as an infinite space of <code>A&#39;s</code> that we index into using <code>S</code>.</li>
<li>If we then consider that <code>cojoin</code> duplicates the structure to <code>Store[S, Store[S, A]]</code>, so we have <code>S =&gt; Store[S, A]</code> which is an infinite space of <code>Store</code> objects indexed by <code>S</code>.</li>
<li>If we then index into this infinite space of <code>Store</code> objects using an <code>S</code> we will obtain a <code>Store[S, A]</code> with the same structure as our original, but with the focus set to the index used to extract the <code>Store</code> instance.</li>
</ul>
<p>So, for every <code>A</code> we could extract from the original <code>Store</code> using some <code>S</code> we can extract a <code>Store[S, A]</code> from the <code>cojoin</code>ed store using the same the same <code>S</code> and the focus will be defined by the provided <code>S</code> index. </p>
<p>In other words, for every “element” in the original <code>Store</code>, we can obtain another <code>Store</code> focused on that “element”.</p>
<h2 id="Game-Of-Life"><a href="#Game-Of-Life" class="headerlink" title="Game Of Life"></a>Game Of Life</h2><p>The game of life is a two-dimensional grid, where each cell is either alive or dead. In each generation a simple set of rules are applied at each cell to determine the next generation.</p>
<p>We will use the <code>Store</code> comonad to model the game. The index <code>S</code> in our <code>Store</code> will be fixed to <code>(Int, Int)</code>. This pair of <code>Int</code>s will represent x-y coordinates in the grid.</p>
<figure class="highlight scala"><figcaption><span>Types</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Coord</span> </span>= (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Grid</span>[<span class="type">A</span>] </span>= <span class="type">Store</span>[<span class="type">Coord</span>, <span class="type">A</span>]</span><br></pre></td></tr></table></figure>
<p>Before we move on to defining the rules of the game, there is one useful combinator specific to <code>Store</code> that we will need. </p>
<figure class="highlight scala"><figcaption><span>Experiment</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">experiment</span></span>[<span class="type">F</span>[_] : <span class="type">Functor</span>](fn: <span class="type">S</span> =&gt; <span class="type">F</span>[<span class="type">S</span>]): <span class="type">F</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    fn(index).map(lookup)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>experiment</code> function allows a functor valued computation to be applied to the current index, to produce a new index wrapped in that functor. Then extracts the focus for the new index.</p>
<p>In our use case the functor <code>F</code> will be <code>List</code> and we will use <code>experiment</code> to get the values of the neighbours of the current cell.</p>
<p>Now lets look at defining the rules of the game of life. We want to define a function with the following signature</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conway</span></span>(grid: <span class="type">Grid</span>[<span class="type">Boolean</span>]): <span class="type">Boolean</span> = ???</span><br></pre></td></tr></table></figure>
<p>This function, will take the current focus of the <code>Grid</code> as the current cell, and apply the rules of the game of life to determine what the value of the focus should be in the next generation. Remember that <code>Grid[A] = Store[(Int, Int), A]</code>, so this function fits the shape of the function argument to <code>coflatMap</code>, <code>Store[(Int, Int), Boolean] =&gt; Boolean</code>.</p>
<p>Lets complete the implementation of this function.</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conway</span></span>(grid: <span class="type">Grid</span>[<span class="type">Boolean</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> neighbours = grid.experiment[<span class="type">List</span>] &#123; <span class="keyword">case</span> (x, y) =&gt; neighbourCoords(x, y) &#125;</span><br><span class="line">  <span class="keyword">val</span> liveCount = neighbours.count(identity)</span><br><span class="line"></span><br><span class="line">  grid.counit <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> <span class="keyword">if</span> liveCount &lt; <span class="number">2</span> =&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> <span class="keyword">if</span> liveCount == <span class="number">2</span> || liveCount == <span class="number">3</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> <span class="keyword">if</span> liveCount &gt; <span class="number">3</span> =&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span> <span class="keyword">if</span> liveCount == <span class="number">3</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> x =&gt; x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>neighbourCoords</code> is a helper that calculates the coordinates of all neighbours of a given cell.</p>
<figure class="highlight scala"><figcaption><span>Neighbours</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neighbourCoords</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Coord</span>] = <span class="type">List</span>(</span><br><span class="line">  (x + <span class="number">1</span>, y),</span><br><span class="line">  (x - <span class="number">1</span>, y),</span><br><span class="line">  (x, y + <span class="number">1</span>),</span><br><span class="line">  (x, y - <span class="number">1</span>),</span><br><span class="line">  (x + <span class="number">1</span>, y + <span class="number">1</span>),</span><br><span class="line">  (x + <span class="number">1</span>, y - <span class="number">1</span>),</span><br><span class="line">  (x - <span class="number">1</span>, y + <span class="number">1</span>),</span><br><span class="line">  (x - <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>We use the <code>experiment</code> combinator, along with the <code>neighbourCoords</code> function to find all the neighbours of the current cell. We then apply the rules, based on the number of live neighbours, to determine the next state of the current cell.</p>
<p>Finally, we just need to extend the local computation <code>conway</code> to a global one, using <code>coflatMap</code></p>
<figure class="highlight scala"><figcaption><span>Local To Global</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(grid: <span class="type">Grid</span>[<span class="type">Boolean</span>]): <span class="type">Grid</span>[<span class="type">Boolean</span>] =</span><br><span class="line">  grid.coflatMap(conway)</span><br></pre></td></tr></table></figure>
<p>Notice that by leveraging the comonadic structure, we were able to define the rules of the game based on the context local to, or relative to the focus. That is, we only had to define the rules for a given cell, and didn’t need to care about how to apply it globally to all cells.</p>
<p>There is one problem with this implementation though, the performance is exponential in the number of generations, since at each step we need to recalculate all previous generations again. The solution to this, is to memoize the lookup function. There is then far less re-computation of previous states.</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Store</span>[<span class="type">S</span>, <span class="type">B</span>] =</span><br><span class="line">    <span class="type">Store</span>(<span class="type">Store</span>.memoize(lookup.andThen(f)))(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this post I provided an intuition for comonads, using the <code>Zipper</code> data structure as an analogy. I also detailed the <code>Store</code> comonad, and how it fits the same intuition. Then used what we have learned about Comonads to implement <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">Conway’s Game Of Life</a> using the store comonad. </p>
<p>I hope you have found this post helpful, and you now have an intuition and practical understanding of Comonads.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://github.com/eli-jordan/game-of-life-comonad" target="_blank" rel="noopener">Source code</a> for this post</li>
<li><a href="http://chrispenner.ca/posts/conways-game-of-life.html" target="_blank" rel="noopener">Haskell implementation of Life</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/" data-id="cjduy95tx00006uevmr390zum" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/#comments" class="article-comment-link"><span class="fb-comments-count" data-href="https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/">0</span>&nbsp;Comments</a>
    

        </footer>
    </div>
    
</article>


</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/02/16/life-is-a-comonad/" class="title">Life Is A Comonad</a></p>
                            <p class="item-date"><time datetime="2018-02-16T04:30:28.000Z" itemprop="datePublished">2018-02-16</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/comonad/" style="font-size: 10px;">comonad</a> <a href="/tags/functional-programming/" style="font-size: 10px;">functional-programming</a> <a href="/tags/scala/" style="font-size: 10px;">scala</a>
        </div>
    </div>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 Eli Jordan<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
<script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.12";
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>