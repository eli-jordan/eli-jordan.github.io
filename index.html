<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Duality</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Duality"><meta name="msapplication-TileImage" content="images/lambda.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Duality"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Duality"><meta property="og:url" content="https://eli-jordan.github.io/"><meta property="og:site_name" content="Duality"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://eli-jordan.github.io/img/og_image.png"><meta property="article:author" content="Eli Jordan"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://eli-jordan.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://eli-jordan.github.io"},"headline":"Duality","image":["https://eli-jordan.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Eli Jordan"},"publisher":{"@type":"Organization","name":"Duality","logo":{"@type":"ImageObject","url":"https://eli-jordan.github.io/images/lambda.png"}},"description":""}</script><link rel="icon" href="/images/lambda.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/solarized-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-VFGV82WNCJ" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-VFGV82WNCJ');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/lambda.png" alt="Duality" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/.">Home</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/talks">Talks</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-02-16T15:30:28.000Z" title="2/16/2018, 3:30:28 PM">2018-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-07T17:29:23.744Z" title="1/7/2023, 5:29:23 PM">2023-01-07</time></span><span class="level-item">16 minutes read (About 2376 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/16/life-is-a-comonad/">Life Is A Comonad</a></h1><div class="content"><p>I have recently been grappling with the concept of a <code>Comonad</code>, and found that there are quite a few articles that explain their theoretical footing, but not many that convey an intuitive understanding of Comonads using practical examples. Additionally, the practical examples I did find are all in Haskell, which I am not fluent in.</p>
<p>In this post I aim to convey an intuitive understanding of the structure of a <code>Comonad</code>, and how you can use comonads in real(ish) programs.</p>
<h2 id="What-Is-A-Comonad">What Is A Comonad?</h2>
<p>A <code>Comonad</code> is the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dual_%28category_theory%29">categorical dual</a> of a <code>Monad</code>. This simply means that we “reverse the arrows” in the definition of a <code>Monad</code></p>
<figure class="highlight scala"><figcaption><span>Monad / Comonad Duality</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](ffa: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Comonad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">A</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we rewrite the types of these functions slightly differently, the reversal of the arrows becomes more obvious.</p>
<figure class="highlight scala"><figcaption><span>Reversing The Arrows</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unit: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">counit: <span class="type">F</span>[<span class="type">A</span>] =&gt; <span class="type">A</span></span><br><span class="line"></span><br><span class="line">join: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]] =&gt; <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">cojoin: <span class="type">F</span>[<span class="type">A</span>] =&gt; <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="unit-counit"><code>unit</code> / <code>counit</code></h3>
<ul>
<li>In a <code>Monad</code> the <code>unit</code> function takes a pure value, and wraps it in an <code>F</code> structure <code>F[A]</code></li>
<li>In a <code>Comonad</code> the <code>counit</code> function takes an <code>F</code> structure and <strong>extracts</strong> a pure value <code>A</code></li>
</ul>
<h3 id="join-cojoin"><code>join</code> / <code>cojoin</code></h3>
<ul>
<li>In a <code>Monad	</code> the <code>join</code> function takes two layers of <code>F</code> structure <code>F[F[A]]</code> and <strong>collapses</strong> it into one layer <code>F[A]</code></li>
<li>In a <code>Comonad</code> the <code>cojoin</code> function takes one layer of <code>F</code> structure <code>F[A]</code> and <strong>duplicates</strong> it <code>F[F[A]]</code></li>
</ul>
<p>Ok, so now we can see that a <code>Comonad</code> is defined by reversing the arrows in the definition of a <code>Monad</code>, but this doesn’t provide an intuitive understanding of how a <code>Comonad</code> behaves.</p>
<h2 id="The-Intuition">The Intuition</h2>
<p>The <code>Zipper</code> data structure is a good analogy of the behaviour of a <code>Comonad</code>. A <code>Zipper</code> is a sequence of elements, that encodes the idea of a “current” or “focus” element, allowing the focus to be moved left and right efficiently.</p>
<figure class="highlight scala"><figcaption><span>Zipper</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamZipper</span>[<span class="type">A</span>](<span class="params">left: <span class="type">Stream</span>[<span class="type">A</span>], focus: <span class="type">A</span>, right: <span class="type">Stream</span>[<span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">moveLeft</span></span>: <span class="type">StreamZipper</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StreamZipper</span>[<span class="type">A</span>](left.tail, left.head, focus #:: right)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">moveRight</span></span>: <span class="type">StreamZipper</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StreamZipper</span>[<span class="type">A</span>](focus #:: left, right.head, right.tail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>left</code> member contains all elements that precede the focus element, in reverse order. The elements are reversed, so that moving left is just a prepend operation. The <code>right</code> member contains all elements that follow the focus element.</p>
<p>What does this have to do with <code>Comonads</code>? Well, since we have a focus element, we have a way to <strong>extract</strong> an <code>A</code> element from an <code>F[A]</code>, by simply accessing the focus element. This is exactly what we need to implement <code>counit</code></p>
<figure class="highlight scala"><figcaption><span>Counit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">ZipperComonad</span> <span class="keyword">extends</span> <span class="title">Comonad</span>[<span class="type">StreamZipper</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">    fa.focus</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But, we still don’t have an implementation for <code>cojoin</code>. What does it mean to create a <code>StreamZipper[StreamZipper[A]]</code>?</p>
<p>They key insight here, is that we want to generate a <code>StreamZipper</code> where each element has the same elements as the initial <code>StreamZipper</code> but with the focus shifted.</p>
<p>For example, denoting the focus element using <code>&gt;x&lt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cojoin([1, &gt;2&lt;, 3]) = [</span><br><span class="line">   [&gt;1&lt;,  2 ,  3 ], </span><br><span class="line">   [ 1 , &gt;2&lt;,  3 ], </span><br><span class="line">   [ 1 ,  2 , &gt;3&lt;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>So, <code>cojoin</code> <strong>duplicates</strong> our structure, but with the focus in each duplicate shifted to one of the other elements. In the <code>StreamZipper</code> example this means that for each element we create a duplicate of the entire <code>StreamZipper</code> and set the focus on that element.</p>
<p>So lets implement this for <code>StreamZipper</code></p>
<figure class="highlight scala"><figcaption><span>StreamZipper cojoin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamZipper</span>[<span class="type">A</span>](<span class="params">left: <span class="type">Stream</span>[<span class="type">A</span>], focus: <span class="type">A</span>, right: <span class="type">Stream</span>[<span class="type">A</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// A stream of zippers, with the focus set to each element on the left</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> lefts: <span class="type">Stream</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] =</span><br><span class="line">    <span class="type">Stream</span>.iterate(moveLeft)(_.moveLeft).zip(left.tail).map(_._1)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A stream of zippers, with the focus set to each element on the right</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> rights: <span class="type">Stream</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] =</span><br><span class="line">    <span class="type">Stream</span>.iterate(moveRight)(_.moveRight).zip(right.tail).map(_._1)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cojoin: <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]](lefts, <span class="keyword">this</span>, rights)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now defining the <code>Comonad</code> instance is trivial</p>
<figure class="highlight scala"><figcaption><span>Comonad instance</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">ZipperComonad</span> <span class="keyword">extends</span> <span class="title">Comonad</span>[<span class="type">StreamZipper</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">    fa.focus</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">StreamZipper</span>[<span class="type">A</span>]): <span class="type">StreamZipper</span>[<span class="type">StreamZipper</span>[<span class="type">A</span>]] = </span><br><span class="line">    fa.cojoin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Summarising, a <code>Comonad</code> has two operations</p>
<ul>
<li><code>counit</code> extracts a focus element from a structure</li>
<li><code>cojoin</code> extends the structure, so that for every element in the original structure, there is a copy of the structure with the focus on the corresponding element.</li>
</ul>
<h2 id="Comonad-coflatMap">Comonad coflatMap</h2>
<p>You may have noticed that the definition of <code>Monad</code> that I used is a bit different than how it is normally expressed in scala. In particular, I used <code>unit</code> and <code>join</code> rather than <code>unit</code> and <code>flatMap</code>. However, these definitions are equivalent. Taking our definition of monad, we can define <code>flatMap</code> in terms of <code>map</code> and <code>join</code></p>
<figure class="highlight scala"><figcaption><span>Deriving flatMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">A</span>](ffa: <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> <span class="type">F</span>: <span class="type">Functor</span>[<span class="type">F</span>]): <span class="type">F</span>[<span class="type">B</span>] =</span><br><span class="line">     join(<span class="type">F</span>.map(fa)(f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Similarly, for comonad, we can express <code>coflatMap</code> in terms of <code>map</code> and <code>cojoin</code></p>
<figure class="highlight scala"><figcaption><span>Deriving coflatMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Comonad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counit</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cojoin</span></span>[<span class="type">A</span>](fa: <span class="type">F</span>[<span class="type">A</span>]): <span class="type">F</span>[<span class="type">F</span>[<span class="type">A</span>]]</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">coflatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">F</span>[<span class="type">A</span>] =&gt; <span class="type">B</span>)(<span class="keyword">implicit</span> <span class="type">F</span>: <span class="type">Functor</span>[<span class="type">F</span>]): <span class="type">F</span>[<span class="type">B</span>] =</span><br><span class="line">    <span class="type">F</span>.map(cojoin(fa))(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I used this definition, since the intuition for <code>cojoin</code> is easier to understand and describe using the <code>StreamZipper</code>. However, the comonad equivalent of <code>flatMap</code>, called <code>coflatMap</code> is a useful function, and we will need to use it later when implementing the Game Of Life.</p>
<p>This function “extends” a local computation into the global context the comonad holds. If you recall, <code>cojoin</code> generates all possible focus points in the comonad structure. In the <code>StreamZipper</code> example, this was a zipper of zippers, where each focused on a different element.</p>
<p>If we inspect the derivation of <code>coflatMap</code>, we are</p>
<ul>
<li>First using <code>cojoin</code> to get a view on all focal points, then</li>
<li>Using the <code>Functor</code> instance to apply a function that performs a “local” computation at all focal points.</li>
</ul>
<p>So, <code>coflatMap</code> allows us to <strong>extend</strong> a local computation to apply in a global context.</p>
<p>A simple example of this, using the <code>StreamZipper</code> is a sliding average. Say we want to take the average of all possible 3 element sub sections of a <code>StreamZipper[Int]</code>. We can define a function that calculates the average, using local information only, by calculating the average of the current focus, the focus one move left and one move right.</p>
<figure class="highlight scala"><figcaption><span>Local Average</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg</span></span>(a: <span class="type">StreamZipper</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> left = a.moveLeft.focus</span><br><span class="line">   <span class="keyword">val</span> current = a.focus</span><br><span class="line">   <span class="keyword">val</span> right = a.moveRight.focus</span><br><span class="line">   (left + current + right) / <span class="number">3</span>d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can then “extend” this local computation, using <code>coflatMap</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamZipper</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="number">4</span>, <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)).coflatMap(avg).toList</span><br><span class="line"><span class="comment">// List(2.0, 3.0, 4.0, 5.0, 6.0)</span></span><br></pre></td></tr></table></figure>
<h2 id="Store-Comonad">Store Comonad</h2>
<p>Now that you have a basic understanding of how comonads behave, our next goal is to actually use one to implement a non-trivial program. In this case, since the comonad structure is well suited to cellular automaton, we will implement <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game Of Life</a> using the <code>Store</code> comonad.</p>
<p>So, lets first introduce the Store data type. <code>Store</code> is the comonadic dual of the <code>State</code> monad, and takes the following form.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>You can think of <code>S</code> being an abstract index into the store.</li>
<li>The <code>index</code> field then defines the “focus” element, by defining the index</li>
<li>The <code>lookup</code> function is the “accessor” for a value of type <code>A</code> using an index of type <code>S</code></li>
</ul>
<p>Lets define the comonad operations on the this data type.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> counit: <span class="type">A</span> = </span><br><span class="line">    lookup(index)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cojoin: <span class="type">Store</span>[<span class="type">S</span>, <span class="type">Store</span>[<span class="type">S</span>, <span class="type">A</span>]] =</span><br><span class="line">    <span class="type">Store</span>(<span class="type">Store</span>(lookup))(index)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Store</span>[<span class="type">S</span>, <span class="type">B</span>] =</span><br><span class="line">    <span class="type">Store</span>(lookup.andThen(f))(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>One thing to notice is that <code>Store</code> take two type parameters, so to define a <code>Comonad</code> instance we need to fix one of them. In this case we fix <code>S</code>.</p>
<p><code>counit</code> is trivial, we simply apply the <code>lookup</code> function to the current index.</p>
<p><code>cojoin</code> is more interesting.</p>
<ul>
<li>Since we are fixing <code>S</code> we want to generate <code>Store[S, Store[S, A]]</code>.</li>
<li>Since we are replacing <code>A</code> with <code>Store[S, A]</code>, and <code>A</code> is only used in the return type of <code>lookup</code>, we need to define a new <code>lookup</code> function of type <code>S =&gt; Store[S, A]</code>.</li>
<li>We do this by partially applying the store constructor <code>Store(lookup)</code> since this has exactly the type we need.</li>
<li>We then copy the current store, replacing the <code>lookup</code> function with a partially applied constructor and we’re done.</li>
</ul>
<p>The intuition that <code>cojoin</code> duplicates the structure, with the focus shifted, is a little harder to see in <code>Store</code>, but it is still there.</p>
<ul>
<li>We can think of <code>S =&gt; A</code> as an infinite space of <code>A's</code> that we index into using <code>S</code>.</li>
<li>If we then consider that <code>cojoin</code> duplicates the structure to <code>Store[S, Store[S, A]]</code>, so we have <code>S =&gt; Store[S, A]</code> which is an infinite space of <code>Store</code> objects indexed by <code>S</code>.</li>
<li>If we then index into this infinite space of <code>Store</code> objects using an <code>S</code> we will obtain a <code>Store[S, A]</code> with the same structure as our original, but with the focus set to the index used to extract the <code>Store</code> instance.</li>
</ul>
<p>So, for every <code>A</code> we could extract from the original <code>Store</code> using some <code>S</code> we can extract a <code>Store[S, A]</code> from the <code>cojoin</code>ed store using the same the same <code>S</code> and the focus will be defined by the provided <code>S</code> index.</p>
<p>In other words, for every “element” in the original <code>Store</code>, we can obtain another <code>Store</code> focused on that “element”.</p>
<h2 id="Game-Of-Life">Game Of Life</h2>
<p>The game of life is a two-dimensional grid, where each cell is either alive or dead. In each generation a simple set of rules are applied at each cell to determine the next generation.</p>
<p>We will use the <code>Store</code> comonad to model the game. The index <code>S</code> in our <code>Store</code> will be fixed to <code>(Int, Int)</code>. This pair of <code>Int</code>s will represent x-y coordinates in the grid.</p>
<figure class="highlight scala"><figcaption><span>Types</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Coord</span> </span>= (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Grid</span>[<span class="type">A</span>] </span>= <span class="type">Store</span>[<span class="type">Coord</span>, <span class="type">A</span>]</span><br></pre></td></tr></table></figure>
<p>Before we move on to defining the rules of the game, there is one useful combinator specific to <code>Store</code> that we will need.</p>
<figure class="highlight scala"><figcaption><span>Experiment</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">experiment</span></span>[<span class="type">F</span>[_] : <span class="type">Functor</span>](fn: <span class="type">S</span> =&gt; <span class="type">F</span>[<span class="type">S</span>]): <span class="type">F</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    fn(index).map(lookup)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>experiment</code> function allows a functor valued computation to be applied to the current index, to produce a new index wrapped in that functor. Then extracts the focus for the new index.</p>
<p>In our use case the functor <code>F</code> will be <code>List</code> and we will use <code>experiment</code> to get the values of the neighbours of the current cell.</p>
<p>Now lets look at defining the rules of the game of life. We want to define a function with the following signature</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conway</span></span>(grid: <span class="type">Grid</span>[<span class="type">Boolean</span>]): <span class="type">Boolean</span> = ???</span><br></pre></td></tr></table></figure>
<p>This function, will take the current focus of the <code>Grid</code> as the current cell, and apply the rules of the game of life to determine what the value of the focus should be in the next generation. Remember that <code>Grid[A] = Store[(Int, Int), A]</code>, so this function fits the shape of the function argument to <code>coflatMap</code>, <code>Store[(Int, Int), Boolean] =&gt; Boolean</code>.</p>
<p>Lets complete the implementation of this function.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conway</span></span>(grid: <span class="type">Grid</span>[<span class="type">Boolean</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> neighbours = grid.experiment[<span class="type">List</span>] &#123; <span class="keyword">case</span> (x, y) =&gt; neighbourCoords(x, y) &#125;</span><br><span class="line">  <span class="keyword">val</span> liveCount = neighbours.count(identity)</span><br><span class="line"></span><br><span class="line">  grid.counit <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> <span class="keyword">if</span> liveCount &lt; <span class="number">2</span> =&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> <span class="keyword">if</span> liveCount == <span class="number">2</span> || liveCount == <span class="number">3</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> <span class="keyword">if</span> liveCount &gt; <span class="number">3</span> =&gt; <span class="literal">false</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span> <span class="keyword">if</span> liveCount == <span class="number">3</span> =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> x =&gt; x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>neighbourCoords</code> is a helper that calculates the coordinates of all neighbours of a given cell.</p>
<figure class="highlight scala"><figcaption><span>Neighbours</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neighbourCoords</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Coord</span>] = <span class="type">List</span>(</span><br><span class="line">  (x + <span class="number">1</span>, y),</span><br><span class="line">  (x - <span class="number">1</span>, y),</span><br><span class="line">  (x, y + <span class="number">1</span>),</span><br><span class="line">  (x, y - <span class="number">1</span>),</span><br><span class="line">  (x + <span class="number">1</span>, y + <span class="number">1</span>),</span><br><span class="line">  (x + <span class="number">1</span>, y - <span class="number">1</span>),</span><br><span class="line">  (x - <span class="number">1</span>, y + <span class="number">1</span>),</span><br><span class="line">  (x - <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>We use the <code>experiment</code> combinator, along with the <code>neighbourCoords</code> function to find all the neighbours of the current cell. We then apply the rules, based on the number of live neighbours, to determine the next state of the current cell.</p>
<p>Finally, we just need to extend the local computation <code>conway</code> to a global one, using <code>coflatMap</code></p>
<figure class="highlight scala"><figcaption><span>Local To Global</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(grid: <span class="type">Grid</span>[<span class="type">Boolean</span>]): <span class="type">Grid</span>[<span class="type">Boolean</span>] =</span><br><span class="line">  grid.coflatMap(conway)</span><br></pre></td></tr></table></figure>
<p>Notice that by leveraging the comonadic structure, we were able to define the rules of the game based on the context local to, or relative to the focus. That is, we only had to define the rules for a given cell, and didn’t need to care about how to apply it globally to all cells.</p>
<p>There is one problem with this implementation though, the performance is exponential in the number of generations, since at each step we need to recalculate all previous generations again. The solution to this, is to memoize the lookup function. There is then far less re-computation of previous states.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>[<span class="type">S</span>, <span class="type">A</span>](<span class="params">lookup: <span class="type">S</span> =&gt; <span class="type">A</span></span>)(<span class="params">val index: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">Store</span>[<span class="type">S</span>, <span class="type">B</span>] =</span><br><span class="line">    <span class="type">Store</span>(<span class="type">Store</span>.memoize(lookup.andThen(f)))(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conclusion">Conclusion</h2>
<p>In this post I provided an intuition for comonads, using the <code>Zipper</code> data structure as an analogy. I also detailed the <code>Store</code> comonad, and how it fits the same intuition. Then used what we have learned about Comonads to implement <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game Of Life</a> using the store comonad.</p>
<p>I hope you have found this post helpful, and you now have an intuition and practical understanding of Comonads.</p>
<h2 id="References">References</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/eli-jordan/game-of-life-comonad">Source code</a> for this post</li>
<li><a target="_blank" rel="noopener" href="http://chrispenner.ca/posts/conways-game-of-life.html">Haskell implementation of Life</a></li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/me.jpeg" alt="Eli Jordan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Eli Jordan</p><p class="is-size-6 is-block">Staff Software Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Oslo, Norway</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Post</p><a href="/archives"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://github.com/eli-jordan" target="_blank" rel="noopener">Follow</a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/eli-jordan" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://www.linkedin.com/in/elijordan/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LinkedIn</span></span><span class="level-right"><span class="level-item tag">www.linkedin.com</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2018-02-16T15:30:28.000Z">2018-02-16</time></p><p class="title"><a href="/2018/02/16/life-is-a-comonad/">Life Is A Comonad</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/comonad/"><span class="tag">comonad</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/functional-programming/"><span class="tag">functional-programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/scala/"><span class="tag">scala</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/lambda.png" alt="Duality" height="28"></a><p class="is-size-7"><span>&copy; 2023 Eli Jordan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>